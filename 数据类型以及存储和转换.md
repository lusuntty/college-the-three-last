# 数据类型以及存储和转换

### 数据类型分类

+ 基本（原始）类型（number,string,boolean,null,undefined）
+ 引用（对象）类型（object(array,function,date,error等)）

> **typeof——判断数据类型**
>
> * 返回一个字符串，表示未经计算的操作数的类型。
>
> * typeof operand  or  typeof (operand)

![](https://i.imgur.com/ZHNGw7r.png)

> **值和类型**
>
> * JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。（动态类型）
>
> * 在对变量执行 typeof 操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型，因为 JavaScript 中的变量没有类型。



### 数据类型存储

+ **栈/堆**

​      var a = 20;

​      var b = 'abc';

​      var c = true;

​      var d = { m: 20 }

![](https://i.imgur.com/xSGyosR.png)



+ 栈内存主要是**按值访问**，而堆内存**按引用访问**

![](https://i.imgur.com/pvV1MFC.png)

+ **基本类型的存储**

​        基本类型的变量是存放在栈区的， 且基本类型的值是不可变的。

+ **引用类型的存储**

  引用类型的值是同时保存在栈内存和堆内存中的对象。

+ **基本类型与引用类型的区别**

​        访问机制不同
​        复制变量不同
​        比较变量不同
​        参数传递不同



### 访问机制

+  **原始类型的值直接访问**

+ **对象类型的值通过引用访问，不能直接访问**

+ +  首先，从栈中获取该对象的地址引用
  +  其次，再从堆内存中取得我们需要的数据

  ![](https://i.imgur.com/DVVV3CW.png)



### 复制变量

+  **基本类型复制 —— 相互独立互不影响**

![](https://i.imgur.com/7hhGf31.png)

![](https://i.imgur.com/NZHNzrp.png)



+ **引用类型复制**

  ![](https://i.imgur.com/AkAqNRU.png)

  ![](https://i.imgur.com/cgZ29wd.png)



### 比较变量

+ **基本数据类型与引用类型的比较**
+ + 值类型是判断变量的值是否相等（值比较）
  + 引用类型是判断所指向的内存空间（地址）是否相同（引用比较）

![](https://i.imgur.com/Mus7qS8.png)

![](https://i.imgur.com/3tl3xLs.png)



### 参数传递

+ **ECMAScript 中所有函数的参数都是按值来传递的**
+ + 基本类型值：把变量里的数据值传递给参数，之后参数和变量互不影响。
  + 引用类型值：把对象的引用（地址）值传递给参数，参数和对象都指向同一个对象，相互影响。

![](https://i.imgur.com/jZCkReL.png)

![](https://i.imgur.com/ipbMPt5.png)



|      | **使用值**                                                   | **使用引用**                                                 |
| ---- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 复制 | 实际复制的是值，存在两个不同的、独立的副本                   | 复制的只是对数值的引用。如果通过这个新的引用修改了数值，这个改变对原始的引用来说也可见 |
| 传递 | 传递给函数的是值的一个独立的副本，对它的改变在函数外部没有影响 | 传递给函数的是对数值的一个引用。如函数通过传递给它的引用修改了数值，这个改变在函数外部也可见 |
| 比较 | 比较的是两个独立的值(通常逐字节比较),以判断它们是否相同      | 比较的是两个引用，以判断它们引用的是否是同一个数值。对两个不同的数值的引用不相等，即使这两个数值是由相同的字节构成的 |



### 数据类型转换

* **类型转换 —— 将值从一种类型转换为另一种类型 **

1.  隐式类型转换：通常是某些操作的副作用，不易看出

![](https://i.imgur.com/iRRK7dK.png)

2. 强制类型转换：可以在代码中明显看出

![](https://i.imgur.com/pnOnamL.png)



3.  转换为 Number 类型规则

![](https://i.imgur.com/P88MJGF.png)

4.  强制转换为 Number 类型

​        *parseInt()、parseFloat()、Number()*

+ **NaN** (Not a Number)

​       表示一个没有意义、不正确的数值
​       console.log( typeof  NaN);  ---Number
​       与自身不相等   --- NaN!=NaN

​      + *认识  isNaN()函数*

​      用来检测参数是否为 NaN 值
​     参数是 "NaN" 时返回 true，否则返回 false
​     isNaN("123abc")    —— true

5.  转换为 String 类型规则

![](https://i.imgur.com/6R3C5P9.png)

6. 强制转换为 String 类型
    String()

7. 1.  “+”运算符 *左右两侧*  有字符串时为拼接运算符。

   2. 运算符等级相同时，*从左往右* 计算。

8.  转换为 Boolean 类型规则

![](https://i.imgur.com/PugLL8y.png)

9. 强制转换为 Boolean 类型
    Boolean()

​        + 逻辑运算符会将数据类型转换为布尔类型之后再做运算

+ **包装对象**

​       JavaScript 对象是一种复合值，是属性的集合。

​     *包装对象*
​      存取字符串、数字或布尔值的属性时创建的临时对象称为包装对象区分字符值和字符串对象、数字和数值对象、布尔值和布尔对象字符串、数字和布尔值的属性时只读的
​       通过 String()，Number()，Boolean() 构造函数显示创建包装对象



10. 转换为 Object 类型
     对象转换为自身
     undefined 和 null 转换为空对象{}
     string/number/boolean 转换为包装对象
11.  Object 转换为 Boolean
     任意对象转换为布尔值为 true，包括空对象

![](https://i.imgur.com/92IYbdr.png)

12.  Object 转换为 Number
     先调用 valueOf() 方法，结果为原始值，返回；
     再调用 toString() 方法，结果为原始值，返回；
     原始值转换为 Number 类型
13.  Object 转换为 String
     先调用 toString() 方法，结果为原始值，返回；
     再调用 valueOf() 方法，结果为原始值，返回；
     原始值转换为 String 类型

+ **== (宽松相等)**

 **不同数据类型判断宽松相等**
 undefined 和 null，它们被认为是宽松相等的（undefined == null //true）
 一个字符串和一个数字，则将字符串转换为一个数字
 一个布尔值和一个非布尔值，则将布尔值转换为一个数字，然后(再次)进行宽松比较。
 一个对象和一个数字，字符串，布尔值，则尝试转换此对象为一个原始值然后(再次)进行宽松比较
不符合上述提到的情况，宽松比较的结果是 false

+  **+ 号**
   算数加号
   拼接符 

