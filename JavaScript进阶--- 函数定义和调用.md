# JavaScript进阶--- 函数定义和调用

### 执行上下文

> **执行上下文**

+ 执行上下文（execution context）
   函数每调用一次，就会创建一个新的执行上下文
   函数执行结束，相应的执行上下文销毁
+ 执行上下文栈（Execution context stack，ECS）
   执行上下文栈按照函数的调用顺序来管理执行上下文
   栈底永远是全局上下文，栈顶是当前正在执行的函数

> **调用栈**

+ 调用栈（Call Stack）

  代码执行时JavaScript 引擎会以栈的方式来 *处理和追踪* 函数调用
  *栈底* 对应的是全局上下文环境，而 *栈顶* 对应的是当前正在执行的上下文环境

![](https://i.imgur.com/369wglB.png)

> **return语句**

+ return 语句的作用
   返回值
   终止函数的执行

> **生命周期**

+ 执行上下文的生命周期
  1. 创建阶段
        创建变量对象
        确定作用域链
        确定this指向
  2.  执行阶段
        变量赋值
        函数引用
        执行代码

![](https://i.imgur.com/ZZpFwfi.png)



### 变量对象

+ 变量对象（Variable Object）
   函数的所有形参
   当前上下文中的所有函数声明
   当前上下文中所有变量声明

> **预编译（预解析）**

+ JavaScript代码的整个执行过程
   JavaScript 引擎是*一段一段* 地运行代码的
   执行每一段代码之前，都有一个“预编译”
+ JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段
   编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。
   执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。

> **声明提升**

+ 声明提升
   JavaScript 引擎把所有的变量声明和函数声明提升到当前作用域的最前面
   规则1：函数声明整体提前（注意：函数表达式）
   规则2：变量声明提前，赋值留在原地
   规则3：函数会首先被提升，然后才是变量（注意：重复的 var 声明会被忽略，函数声明可以覆盖前面的）

> **活动对象**

+ 活动对象（Activation Object）
   执行阶段的变量对象

> **全局上下文的变量对象**

+ 浏览器中的全局上下文的变量对象
    变量对象就是 window 对象
    不会变成活动对象
    在页面关闭前一直存在

### 作用域链

> **作用域**

+ 几乎所有的编程语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个值进行访问和修改。

+ 变量储存在哪里以及程序需要时如何找到他们，这些问题说明需要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。这套规则称为作用域。

+ 作用域这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。

+ 什么是作用域？

  作用域就是变量与函数的可访问范围
  作用域控制着变量与函数的可见性和生命周期

> **作用域类型**

+ 全局作用域（global scope）
+ 函数作用域（function scope）
+ 块作用域（block scope）
   ES5 没有块作用域，在 ES6 中添加了块作用域
   任何一对花括号 { } 中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域

> **作用域模型**

+ 作用域共有两种主要的工作模型
     词法作用域（静态性）
        是由变量和函数定义的书写位置决定的，与调用位置无关
    动态作用域（动态性）
        由调用位置决定，不关心变量和函数的定义的书写位置

> **词法作用域**

+ JavaScript作用域 —— 词法作用域（lexical scope）
     词法作用域具有静态性，静态结构决定了一个变量的作用域
     词法作用域与定义位置有关，与调用形式无关
+ 词法作用域补充部分
  – 通过 new Function 创建的函数对象不遵从静态词法作用域
  – 通过 new Function 创建的函数对象总是在全局作用域中执行
+ 作用域嵌套 —— 变量查找
   作用域查找会在找到 *第一个匹配的标识符时停止*
   作用域查找只会找一级标识符

> **[[scope]]**

+   [[scope]] 属性

  虚拟属性，无法访问和修改
   函数创建（定义）时生成的属性，保存着这个函数的父作用域的作用域链

> **作用域链**

+ 作用域链（Scope Chain）
   由当前执行环境与上层（父级）执行环境的一系列变量对象组成
   提供对变量和函数访问的权限和顺序的规则

**总结**

+ 作用域链与执行上下文
   执行时，当前执行上下文，对应一个作用域链环境来管理和解析变量和函数（动态性）
   变量查找按照由内到外的顺序（遵循词法作用域），直到完成查找，若未查询到则报错
   当函数执行结束，运行期上下文被销毁，此作用域链环境也随之被释放
+ 变量的管理
   当程序运行到变量所在的作用域时，变量被创建，此时需要一个存储的空间
   JS中提供存储空间的数据结构被称为环境，每个函数都有自己的执行环境
   每个执行环境都有一个与之关联的变量对象，环境中所有变量和函数都保存在此对象中
  Web浏览器中，全局执行环境为window对象
+ 作用域链（在 ECMA262 中的解释，涉及到内部属性）
  任何执行上下文时刻的作用域，都是由作用域链 (scope chain) 来实现。 在一个函数被定义的时候，会将它定义时候的 scope chain 链接到这个函数对象的[[scope]]属性。 在一个函数对象被调用的时候，会创建一个活动对象 (也就是一个对象，然后对于每一个函数的形参，都命名为该活动对象的命名属性，然后将这个活动对象做为此时的作用域链 (scope chain) 最前端， 并将这个函数对象的 [[scope]] 加入到 scope chain 中