# JavaScript进阶--闭包

> #### **LHS/RHS** ####

+ 当变量出现在赋值操作的左侧时进行*LHS*查询

+  理解：赋值操作的目标是谁，不关心它的当前值

+  当变量出现在赋值操作的右侧时进行 *RHS* 查询

+  理解：取到它的源值，这意味着得到某某变量的值

  

+ 为什么要区分LHS和RHS？

​      因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。





> #### **闭包（closure）** ####

+ 闭包是由函数和其相关的引用环境组合而成的实体
  闭包是词法作用域中的函数和其相关变量的包裹体

1. 执行上下文（代号A）

2. 在执行上下文中创建的函数（代号B）
3. 当B（函数）执行时，如果访问了A中变量对象中的值，就会产生闭包
4. 闭包产生过程：

![](https://i.imgur.com/FWkw0aQ.png)



+ **闭包与作用域链**

一、 作用域规则在代码编译阶段确定，即在代码书写之后作用域链就已确定

            1. 作用域链在代码执行时生成
            2. 变量查找按照作用域链 *由内到外* 的顺序（遵循词法作用域），直到完成查找，若未查询到则报错

二、  调用栈在代码执行时确定，作用是 **处理和追踪** 函数调用



+ **闭包的作用**

一、 可通过闭包访问隐藏在函数作用域内的局部变量

二、 使函数中的变量被保存在内存中不被释放



+ **垃圾回收机制**

一、 执行上下文（execution context）

1. 函数每调用一次，就会创建一个新的执行上下文
2.  函数执行结束，相应的执行上下文销毁

二、 闭包：使函数中的变量被保存在内存中不被释放

三、 垃圾回收机制（Garbage Collection）

1.  内存声明周期

   *分配内存*

   *使用内存*

   *释放内存：*

   * 全局变量
   * 定时器
   * 对象引用

2. 垃圾回收方法

   *引用计数*

   *标记-—清除*



+ **闭包的常见形式—— 以普通函数形式返回**



![](https://i.imgur.com/YtgdSeN.png)



![](https://i.imgur.com/XkVsmDA.png)



![](https://i.imgur.com/O3TVQYy.png)



+ **闭包常见形式——作为对象的方法返回**

![](https://i.imgur.com/Y6HA4Tv.png)



![](https://i.imgur.com/1QNVeQX.png)



> ####  **IIFE** (Immediately-Invoked Function Expression) #### 

* 立即执行的函数表达式
* 立即执行函数也能返回值并且可以赋值给其它变量
* 立即执行函数只能执行一次，而命名的函数可重复调用

![](https://i.imgur.com/zvODBFi.png)

* IIFE应用 : 解决变量共享、变量污染问题